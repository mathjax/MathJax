(()=>{"use strict";var e={d:(t,r)=>{for(var a in r)e.o(r,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:r[a]})}};e.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),e.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var t={};e.r(t),e.d(t,{BraketItem:()=>x});var r={};e.r(r),e.d(r,{default:()=>N});var a={};e.r(a),e.d(a,{BraketConfiguration:()=>S});const o=("undefined"!=typeof window?window:e.g).MathJax._.components.global,n=(o.GLOBAL,o.isObject,o.combineConfig,o.combineDefaults,o.combineWithMathJax),s=(o.MathJax,MathJax._.input.tex.HandlerTypes),i=s.ConfigurationType,c=s.HandlerType,l=MathJax._.input.tex.Configuration,h=l.Configuration,p=(l.ConfigurationHandler,l.ParserConfiguration,MathJax._.input.tex.StackItem),u=(p.MmlStack,p.BaseItem),d=MathJax._.core.MmlTree.MmlNode,m=d.TEXCLASS,M=(d.TEXCLASSNAMES,d.MATHVARIANTS,d.indentAttributes,d.AbstractMmlNode,d.AbstractMmlTokenNode,d.AbstractMmlLayoutNode,d.AbstractMmlBaseNode,d.AbstractMmlEmptyNode,d.TextNode,d.XMLNode,MathJax._.input.tex.ParseUtil),b=(M.KeyValueDef,M.KeyValueTypes,M.ParseUtil),g=MathJax._.util.lengths,k=(g.BIGDIMEN,g.UNITS,g.RELUNITS,g.MATHSPACE),y=(g.length2em,g.percent,g.em),f=(g.px,y(k.thinmathspace));class x extends u{constructor(){super(...arguments),this.barNodes=[]}get kind(){return"braket"}get isOpen(){return!0}checkItem(e){return e.isKind("close")?e.getProperty("braketbar")?(this.barNodes.push(...super.toMml(!0,!0).childNodes),this.Clear(),u.fail):[[this.factory.create("mml",this.toMml())],!0]:e.isKind("mml")?(this.Push(e.toMml()),this.getProperty("single")?[[this.toMml()],!0]:u.fail):super.checkItem(e)}toMml(e=!0,t){let r=super.toMml(e,t);if(!e)return r;const a=this.getProperty("open"),o=this.getProperty("close");if(this.barNodes.length&&(r=this.create("node","inferredMrow",[...this.barNodes,r])),this.getProperty("stretchy"))return this.getProperty("space")&&(r=this.create("node","inferredMrow",[this.create("token","mspace",{width:f}),r,this.create("token","mspace",{width:f})])),b.fenced(this.factory.configuration,a,r,o);const n={fence:!0,stretchy:!1,symmetric:!0,texClass:m.OPEN},s=this.create("token","mo",n,a);n.texClass=m.CLOSE;const i=this.create("token","mo",n,o);return this.create("node","mrow",[s,r,i],{open:a,close:o})}}const P=MathJax._.input.tex.TokenMap,A=(P.parseResult,P.AbstractTokenMap,P.RegExpMap,P.AbstractParseMap,P.CharacterMap,P.DelimiterMap,P.MacroMap),T=P.CommandMap,B=(P.EnvironmentMap,MathJax._.input.tex.base.BaseMethods),C=(B.splitAlignArray,B.default),N={Braket(e,t,r,a,o,n,s=!1){const i=e.i;e.GetArgument(t),e.i=i;let c=!0;"{"===e.GetNext()&&(e.i++,c=!1);const l=e.itemFactory.create("braket");l.setProperties({barcount:0,barmax:n,open:r,close:a,stretchy:o,single:c,space:s}),e.Push(l),l.env.braketItem=e.stack.height-1},Bar(e,t){let r="|"===t?"|":"\u2016";const a=e.stack.height-e.stack.env.braketItem,o=e.stack.Top(a);if(!o||!o.isKind("braket")||o.getProperty("barcount")>=o.getProperty("barmax"))return!1;if("|"===r&&"|"===e.GetNext()&&(e.i++,r="\u2016"),!o.getProperty("stretchy")){const t=e.create("token","mo",{stretchy:!1,"data-braketbar":!0,texClass:m.ORD},r);return e.Push(t),!0}const n=e.itemFactory.create("close").setProperty("braketbar",!0);return e.Push(n),o.barNodes.push(e.create("node","TeXAtom",[],{texClass:m.CLOSE}),e.create("token","mo",{stretchy:!0,"data-braketbar":!0,texClass:m.BIN},r),e.create("node","TeXAtom",[],{texClass:m.OPEN})),o.setProperty("barcount",o.getProperty("barcount")+1),!0},Macro:C.Macro};new T("Braket-macros",{bra:[N.Macro,"{\\langle {#1} \\vert}",1],ket:[N.Macro,"{\\vert {#1} \\rangle}",1],braket:[N.Braket,"\u27e8","\u27e9",!1,1/0],set:[N.Braket,"{","}",!1,1],Bra:[N.Macro,"{\\left\\langle {#1} \\right\\vert}",1],Ket:[N.Macro,"{\\left\\vert {#1} \\right\\rangle}",1],Braket:[N.Braket,"\u27e8","\u27e9",!0,1/0],Set:[N.Braket,"{","}",!0,1,!0],ketbra:[N.Macro,"{\\vert {#1} \\rangle\\langle {#2} \\vert}",2],Ketbra:[N.Macro,"{\\left\\vert {#1} \\right\\rangle\\left\\langle {#2} \\right\\vert}",2],"|":N.Bar}),new A("Braket-characters",{"|":N.Bar});const S=h.create("braket",{[i.HANDLER]:{[c.CHARACTER]:["Braket-characters"],[c.MACRO]:["Braket-macros"]},[i.ITEMS]:{[x.prototype.kind]:x},[i.PRIORITY]:3});MathJax.loader&&MathJax.loader.checkVersion("[tex]/braket","4.1.0","tex-extension"),n({_:{input:{tex:{braket:{BraketConfiguration:a,BraketItems:t,BraketMethods:r}}}}})})();