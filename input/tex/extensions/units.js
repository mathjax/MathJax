(()=>{"use strict";var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{UnitsConfiguration:()=>l,UnitsMethods:()=>u});const n=("undefined"!=typeof window?window:global).MathJax._.components.global,i=(n.GLOBAL,n.isObject,n.combineConfig,n.combineDefaults,n.combineWithMathJax),a=(n.MathJax,MathJax._.input.tex.Configuration),o=a.Configuration,r=(a.ConfigurationHandler,a.ParserConfiguration,MathJax._.input.tex.TexParser.default),s=MathJax._.input.tex.TokenMap,c=(s.parseResult,s.AbstractTokenMap,s.RegExpMap,s.AbstractParseMap,s.CharacterMap,s.DelimiterMap,s.MacroMap,s.CommandMap);s.EnvironmentMap;let u={Unit:function(t,e){let n=t.GetBrackets(e),i=`\\mathrm{${t.GetArgument(e)}}`;n&&(i=n+(t.options.units.loose?"~":"\\,")+i),t.string=i+t.string.slice(t.i),t.i=0},UnitFrac:function(t,e){let n=t.GetBrackets(e)||"",i=`\\nicefrac[\\mathrm]{${t.GetArgument(e)}}{${t.GetArgument(e)}}`;n&&(i=n+(t.options.units.loose?"~":"\\,")+i),t.string=i+t.string.slice(t.i),t.i=0},NiceFrac:function(t,e){let n=t.GetBrackets(e)||"\\mathrm",i=t.GetArgument(e),a=t.GetArgument(e),o=new r(`${n}{${i}}`,Object.assign({},t.stack.env),t.configuration).mml(),s=new r(`${n}{${a}}`,Object.assign({},t.stack.env),t.configuration).mml();const c=t.options.units.ugly?{}:{bevelled:!0},u=t.create("node","mfrac",[o,s],c);t.Push(u)}};new c("units",{units:"Unit",unitfrac:"UnitFrac",nicefrac:"NiceFrac"},u);const l=o.create("units",{handler:{macro:["units"]},options:{units:{loose:!1,ugly:!1}}});MathJax.loader&&MathJax.loader.checkVersion("[tex]/units","4.0.0-beta.6","tex-extension"),i({_:{input:{tex:{units:{UnitsConfiguration:e}}}}})})();