(()=>{"use strict";var e={d:(t,a)=>{for(var o in a)e.o(a,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:a[o]})}};e.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),e.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var t={};e.r(t),e.d(t,{RequireConfiguration:()=>_,RequireLoad:()=>j,RequireMethods:()=>A,options:()=>J});const a=("undefined"!=typeof window?window:e.g).MathJax._.components.global,o=(a.GLOBAL,a.isObject,a.combineConfig,a.combineDefaults,a.combineWithMathJax),r=(a.MathJax,MathJax._.input.tex.HandlerTypes),n=r.ConfigurationType,i=r.HandlerType,s=MathJax._.input.tex.Configuration,p=s.Configuration,u=s.ConfigurationHandler,c=(s.ParserConfiguration,MathJax._.input.tex.TokenMap),l=(c.parseResult,c.AbstractTokenMap,c.RegExpMap,c.AbstractParseMap,c.CharacterMap,c.DelimiterMap,c.MacroMap,c.CommandMap),d=(c.EnvironmentMap,MathJax._.input.tex.TexError.default),f=("undefined"!=typeof window?window:e.g).MathJax._.components.startup,h=(f.Startup,f.MathJax),g=(f.CONFIG,MathJax._.components.package),x=(g.PackageError,g.Package),w=("undefined"!=typeof window?window:e.g).MathJax._.components.loader,m=(w.PathFilters,w.Loader),O=(w.MathJax,w.CONFIG),M=MathJax._.mathjax.mathjax,b=MathJax._.util.Options,y=(b.isObject,b.APPEND,b.REMOVE,b.OPTIONS,b.Expandable,b.expandable),q=(b.makeArray,b.keys,b.copy,b.insert,b.defaultOptions,b.userOptions,b.selectOptions,b.selectOptionsFromKeys,b.separateOptions,b.lookup,h.config);function k(e,t){const a=e.parseOptions.options.require,o=e.parseOptions.packageData.get("require").required,r=t.substring(a.prefix.length);if(!o.includes(r)){o.push(r);const a=function(e,t=[]){const a=e.parseOptions.options.require.prefix,o=[];for(const r of t)if(r.substring(0,a.length)===a)try{k(e,r)}catch(e){if(!e.retry)throw e;o.push(e.retry)}return o.length?Promise.all(o):null}(e,O.dependencies[t]);a?M.retryAfter(a.then((()=>P(e,t,r)))):P(e,t,r)}}function P(e,t,a){const o=u.get(a);if(o){let r=q[t]||{};o.options&&1===Object.keys(o.options).length&&o.options[a]&&(r={[a]:r}),e.configuration.add(a,e,r);const n=e.parseOptions.packageData.get("require").configured;o.preprocessors.length&&!n.has(a)&&(n.set(a,!0),M.retryAfter(Promise.resolve()))}}function j(e,t){var a,o;const r=e.options.require,n=r.allow,i=("["===t.substring(0,1)?"":r.prefix)+t;if(!(Object.hasOwn(n,i)?n[i]:Object.hasOwn(n,t)?n[t]:r.defaultAllow))throw new d("BadRequire",'Extension "%1" is not allowed to be loaded',i);const s=x.packages.get(i);if(s||M.retryAfter(m.load(i).catch((e=>{}))),s.hasFailed)throw new d("RequireFail",'Extension "%1" failed to load',t);const p=null===(a=O[i])||void 0===a?void 0:a.rendererExtensions,u=null===(o=h.startup.document)||void 0===o?void 0:o.menu;p&&u&&u.addRequiredExtensions(p),k(e.configuration.packageData.get("require").jax,i)}const A={Require(e,t){const a=e.GetArgument(t);if(a.match(/[^_a-zA-Z0-9]/)||""===a)throw new d("BadPackageName","Argument for %1 is not a valid package name",t);j(e,a),e.Push(e.itemFactory.create("null"))}},J={require:{allow:y({base:!1,autoload:!1,configmacros:!1,tagformat:!1,setoptions:!1,texhtml:!1}),defaultAllow:!0,prefix:"tex"}};new l("require",{require:A.Require});const _=p.create("require",{[n.HANDLER]:{[i.MACRO]:["require"]},[n.CONFIG]:function(e,t){t.parseOptions.packageData.set("require",{jax:t,required:[...t.options.packages],configured:new Map});const a=t.parseOptions.options.require,o=a.prefix;if(o.match(/[^_a-zA-Z0-9]/))throw Error("Illegal characters used in \\require prefix");O.paths[o]||(O.paths[o]="[mathjax]/input/tex/extensions"),a.prefix="["+o+"]/"},[n.OPTIONS]:J});MathJax.loader&&MathJax.loader.checkVersion("[tex]/require","4.1.0","tex-extension"),o({_:{input:{tex:{require:{RequireConfiguration:t}}}}})})();