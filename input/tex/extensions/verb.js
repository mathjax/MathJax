(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})}};e.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),e.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var t={};e.r(t),e.d(t,{VerbConfiguration:()=>b});const n=("undefined"!=typeof window?window:e.g).MathJax._.components.global,r=(n.GLOBAL,n.isObject,n.combineConfig,n.combineDefaults,n.combineWithMathJax),a=(n.MathJax,MathJax._.input.tex.HandlerTypes),i=a.ConfigurationType,o=a.HandlerType,s=MathJax._.input.tex.Configuration,c=s.Configuration,l=(s.ConfigurationHandler,s.ParserConfiguration,MathJax._.input.tex.TexConstants.TexConstant),u=MathJax._.input.tex.TokenMap,g=(u.parseResult,u.AbstractTokenMap,u.RegExpMap,u.AbstractParseMap,u.CharacterMap,u.DelimiterMap,u.MacroMap,u.CommandMap),p=(u.EnvironmentMap,MathJax._.input.tex.TexError.default);new g("verb",{verb:{Verb(e,t){const n=e.GetNext(),r=++e.i;if(""===n)throw new p("MissingArgFor","Missing argument for %1",t);for(;e.i<e.string.length&&e.string.charAt(e.i)!==n;)e.i++;if(e.i===e.string.length)throw new p("NoClosingDelim","Can't find closing delimiter for %1",e.currentCS);const a=e.string.slice(r,e.i).replace(/ /g,"\xa0");e.i++,e.Push(e.create("token","mtext",{mathvariant:l.Variant.MONOSPACE},a))}}.Verb});const b=c.create("verb",{[i.HANDLER]:{[o.MACRO]:["verb"]}});MathJax.loader&&MathJax.loader.checkVersion("[tex]/verb","4.1.0","tex-extension"),r({_:{input:{tex:{verb:{VerbConfiguration:t}}}}})})();