(()=>{"use strict";var t={d:(e,n)=>{for(var a in n)t.o(n,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{UnicodeConfiguration:()=>x,UnicodeMethods:()=>p});const n=("undefined"!=typeof window?window:global).MathJax._.components.global,a=(n.GLOBAL,n.isObject,n.combineConfig,n.combineDefaults,n.combineWithMathJax),o=(n.MathJax,MathJax._.input.tex.Configuration),i=o.Configuration,r=(o.ConfigurationHandler,o.ParserConfiguration,MathJax._.input.tex.TexError.default),c=MathJax._.input.tex.TokenMap,s=(c.parseResult,c.AbstractTokenMap,c.RegExpMap,c.AbstractParseMap,c.CharacterMap,c.DelimiterMap,c.MacroMap,c.CommandMap),l=(c.EnvironmentMap,MathJax._.input.tex.UnitUtil.UnitUtil),u=MathJax._.input.tex.NodeUtil.default,d=MathJax._.util.Entities,m=(d.options,d.entities,d.add,d.remove,d.translate,d.numeric),h=MathJax._.input.tex.base.BaseConfiguration,f=h.Other;h.BaseTags,h.BaseConfiguration;let p={},g={};p.Unicode=function(t,e){let n=t.GetBrackets(e),a=null,o="";if(n&&(n.replace(/ /g,"").match(/^(\d+(\.\d*)?|\.\d+),(\d+(\.\d*)?|\.\d+)$/)?(a=n.replace(/ /g,"").split(/,/),o=t.GetBrackets(e)):o=n),o.match(/;/))throw new r("BadFont","Font name for %1 can't contain semicolons",t.currentCS);let i=l.trimSpaces(t.GetArgument(e)).replace(/^0x/,"x");if(!i.match(/^(x[0-9A-Fa-f]+|[0-9]+)$/))throw new r("BadUnicode","Argument to %1 must be a number",t.currentCS);let c=parseInt(i.match(/^x/)?"0"+i:i);g[c]?o||(o=g[c][2]):g[c]=[800,200,o,c],a&&(g[c][0]=Math.floor(1e3*parseFloat(a[0])),g[c][1]=Math.floor(1e3*parseFloat(a[1])));let s=t.stack.env.font,d={};o?(g[c][2]=d.fontfamily=o.replace(/'/g,"'"),s&&(s.match(/bold/)&&(d.fontweight="bold"),s.match(/italic|-mathit/)&&(d.fontstyle="italic"))):s&&(d.mathvariant=s);let h=t.create("token","mtext",d,m(i));u.setProperty(h,"unicode",!0),t.Push(h)},p.RawUnicode=function(t,e){const n=t.GetArgument(e).trim();if(!n.match(/^[0-9A-F]{1,6}$/))throw new r("BadRawUnicode","Argument to %1 must a hexadecimal number with 1 to 6 digits",t.currentCS);const a=parseInt(n,16);t.string=String.fromCodePoint(a)+t.string.substring(t.i),t.i=0},p.Char=function(t,e){let n,a=t.GetNext(),o="";const i=t.string.substring(t.i);if("'"===a){if(n=i.match(/^'(?:([0-7]{1,7}) ?|(\\\S)|(.))/u),n)if(n[1])o=String.fromCodePoint(parseInt(n[1],8));else if(n[3])o=n[3];else{t.i+=2;const e=[...t.GetCS()];if(e.length>1)throw new r("InvalidAlphanumeric","Invalid alphanumeric constant for %1",t.currentCS);o=e[0],n=[""]}}else'"'===a?(n=i.match(/^"([0-9A-F]{1,6}) ?/),n&&(o=String.fromCodePoint(parseInt(n[1],16)))):(n=i.match(/^([0-9]{1,7}) ?/),n&&(o=String.fromCodePoint(parseInt(n[1]))));if(!o)throw new r("MissingNumber","Missing numeric constant for %1",t.currentCS);t.i+=n[0].length,o>="0"&&o<="9"?t.Push(t.create("token","mn",{},o)):o.match(/[A-Za-z]/)?t.Push(t.create("token","mi",{},o)):f(t,o)},new s("unicode",{unicode:"Unicode",U:"RawUnicode",char:"Char"},p);const x=i.create("unicode",{handler:{macro:["unicode"]}});MathJax.loader&&MathJax.loader.checkVersion("[tex]/unicode","4.0.0-beta.6","tex-extension"),a({_:{input:{tex:{unicode:{UnicodeConfiguration:e}}}}})})();