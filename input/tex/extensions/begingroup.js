(()=>{"use strict";var e={d:(t,o)=>{for(var a in o)e.o(o,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:o[a]})}};e.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),e.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var t={};e.r(t),e.d(t,{BegingroupStack:()=>R,begingroupStack:()=>O});var o={};e.r(o),e.d(o,{BegingroupMethods:()=>I});var a={};e.r(a),e.d(a,{BegingroupConfiguration:()=>T});const n=("undefined"!=typeof window?window:e.g).MathJax._.components.global,i=(n.GLOBAL,n.isObject,n.combineConfig,n.combineDefaults,n.combineWithMathJax),r=(n.MathJax,MathJax._.input.tex.HandlerTypes),s=r.ConfigurationType,g=r.HandlerType,l=MathJax._.input.tex.Configuration,p=l.Configuration,u=(l.ConfigurationHandler,l.ParserConfiguration,MathJax._.input.tex.TokenMap),d=(u.parseResult,u.AbstractTokenMap,u.RegExpMap,u.AbstractParseMap,u.CharacterMap,u.DelimiterMap),h=(u.MacroMap,u.CommandMap),b=u.EnvironmentMap,M=MathJax._.input.tex.MapHandler,c=M.MapHandler,E=(M.SubHandler,M.SubHandlers,MathJax._.input.tex.TexError.default),N=MathJax._.input.tex.newcommand.NewcommandUtil,f=N.NewcommandTables,x=N.NewcommandPriority,m=(N.NewcommandUtil,MathJax._.input.tex.ParseMethods.default);class R{constructor(e){this.i=x,this.top=x,this.base=x,this.MARKER=Symbol("marker"),this.handlers=e.handlers,this.getGlobal()}getGlobal(){this.global={[f.NEW_DELIMITER]:c.getMap(f.NEW_DELIMITER),[f.NEW_ENVIRONMENT]:c.getMap(f.NEW_ENVIRONMENT),[f.NEW_COMMAND]:c.getMap(f.NEW_COMMAND)}}checkGlobal(e,t){for(const o of t){const t=e.shift(),a=this.handlers.get(R.handlerMap[o]);let n;this.global[o].add(t,this.MARKER);do{const e=a.applicable(t);n=e.lookup(t),e.remove(t)}while(n&&n!==this.MARKER)}return t.map((e=>this.global[e]))}push(){new d(f.NEW_DELIMITER,m.delimiter,{}),new h(f.NEW_COMMAND,{}),new b(f.NEW_ENVIRONMENT,m.environment,{}),this.handlers.add(R.handlerConfig,{},--this.i)}pop(){if(this.i===this.base)throw new E("MissingBegingroup","Missing \\begingroup or extra \\endgroup");this.handlers.remove(R.handlerConfig,{});for(const e of[f.NEW_COMMAND,f.NEW_ENVIRONMENT,f.NEW_DELIMITER])c.register(this.handlers.retrieve(e));this.i++}finish(){this.top=this.i}remove(){for(;this.i<this.top;)this.pop()}reset(){this.top=this.base,this.remove()}sandbox(){this.base=x,this.reset(),this.push(),this.getGlobal(),this.base=x-1}}function O(e){return e.packageData.get("begingroup").stack}R.handlerConfig={[g.DELIMITER]:[f.NEW_DELIMITER],[g.ENVIRONMENT]:[f.NEW_ENVIRONMENT],[g.MACRO]:[f.NEW_DELIMITER,f.NEW_COMMAND]},R.handlerMap={[f.NEW_DELIMITER]:g.DELIMITER,[f.NEW_ENVIRONMENT]:g.ENVIRONMENT,[f.NEW_COMMAND]:g.MACRO};const w=MathJax._.input.tex.base.BaseMethods,_=(w.splitAlignArray,w.default),I={begingroup(e,t){O(e.configuration).push()},endgroup(e,t){O(e.configuration).pop()},reset(e,t){O(e.configuration).reset()},sandbox(e,t){O(e.configuration).sandbox(),e.stack.global.isSandbox=!0},global(e,t){const o=e.i,a="\\"===e.GetNext()?(e.i++,e.GetCS()):"";if(e.i=o,!e.options.begingroup.allowGlobal.includes(a))throw new E("IllegalGlobal","Invalid use of %1",e.currentCS);e.stack.env.isGlobal=!0},macro:_.Macro};new h("begingroup",{begingroup:I.begingroup,endgroup:I.endgroup,global:I.global,gdef:[I.macro,"\\global\\def"],begingroupReset:I.reset,begingroupSandbox:I.sandbox}),new h("begingroup",{begingroup:I.begingroup,endgroup:I.endgroup,global:I.global,gdef:[I.macro,"\\global\\def"],begingroupReset:I.reset,begingroupSandbox:I.sandbox});const T=p.create("begingroup",{[s.HANDLER]:{[g.MACRO]:["begingroup"]},[s.CONFIG]:(e,t)=>{t.parseOptions.packageData.set("begingroup",{stack:new R(t.parseOptions)})},[s.OPTIONS]:{begingroup:{allowGlobal:["let","def","newcommand","DeclareMathOperator","Newextarrow"]}},[s.PREPROCESSORS]:[({data:e})=>O(e).remove()],[s.POSTPROCESSORS]:[({data:e})=>O(e).finish()]});MathJax.loader&&MathJax.loader.checkVersion("[tex]/begingroup","4.1.0","tex-extension"),i({_:{input:{tex:{begingroup:{BegingroupConfiguration:a,BegingroupMethods:o,BegingroupStack:t}}}}})})();